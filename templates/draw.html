
{% extends "layout.html" %}

{% block body %}

	<input type="button" value="print" OnClick="printVerts();sendDatabase();document.write(sverts);">
	<input type="button" value="clear" OnClick="removal();killGeo();camParent.rotation.x=0;//camera.rotation.x -= .1;camera.position.y=0;">
	<input type="button" value="rotate" OnClick="camParent.rotation.x+=.3;//camera.rotation.x += .1;camera.position.y+=200;">
	<input type="button" value="rotate" OnClick="camParent.rotation.x-=.3;//camera.rotation.x -= .1;camera.position.y-=200;">
	<input type="button" value="resetRotate" OnClick="camParent.rotation.x=0;//camera.rotation.x -= .1;camera.position.y=0;">

	<div id="container"></div>
	<script src="three.min.js"></script>
	<script defer="defer">

	var renderer,scene,camera,geometry,material,width,height,tubemesh,count,sverts,z,camParent;
	var draw = false;
	var mousePos;
	var tubes = [];
	sverts = "";

	init();
	animate();

	function kill(){

		var obj, i;
		for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
		    obj = scene.children[ i ];
		    if ( obj !== camera && obj!=light) {
		        scene.remove(obj);
		    }
		}
	}

	function init(){

		count=0;
		z=0.1;

		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		scene = new THREE.Scene();

		var mesher = new THREE.Mesh( new THREE.SphereGeometry( 12, 12, 12 ), new THREE.MeshLambertMaterial( { color:0xFFFF00 } ) );

		//scene.add(mesher);

		var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
		directionalLight.position.set( -1, 0, 0 );
		scene.add( directionalLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
		directionalLight.position.set( 0, 0, -1 );
		scene.add( directionalLight );


		geometry = new THREE.Geometry();
		geometry.name = "Liz_Line";
		//console.log({{idea.idea}});
		var vertString = "{{idea.idea}}" || "20.5,54,29.1,9.5,3,30.1,19.5,-46,31.1,70.5,-83,32.1,135.5,-96,33.1,194.5,-85,34.1,246.5,-41,35.1,267.5,18,36.1,257.5,65,37.1,208.5,78,38.1,154.5,66,39.1,113.5,45,40.1,68.5,23,41.1,4.5,14,42.1,-80.5,7,43.1,-134.5,22,44.1,-169.5,55,45.1,-174.5,94,46.1,-162.5,126,47.1,-127.5,152,48.1,-83.5,160,49.1,-44.5,150,50.1,-25.5,138,51.1,-16.5,127,52.1,-9.5,115,53.1,-5.5,105,54.1,-1.5,95,55.1,2.5,86,56.1,6.5,76,57.1,9.5,67,58.1,9.5,63,59.1,9.5,56,60.1,9.5,52,61.1,9.5,45,62.1,9.5,38,63.1,9.5,34,64.1,9.5,30,65.1,9.5,29,66.1,9.5,26,67.1,9.5,23,68.1,";
		//vertString = {{idea.idea}} || "";
		//console.log(vertString);
		var verts = vertString.split(",");
		//console.log(verts);

		for(var i = 0 ; i < verts.length ; i +=3){
			if(verts[i])
			geometry.vertices.push(new THREE.Vector3(parseFloat(verts[i])||0,parseFloat(verts[i+1])||0,parseFloat(verts[i+2])||0));
		}
		//console.log(geometry.vertices);

		scene.add(geometry);

		var curve = new THREE.SplineCurve3(geometry.vertices);
		var geo = new THREE.TubeGeometry(curve, geometry.vertices.length*5, 12, 3, closed);
		//geometry.dynamic = true;
		tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geo, [new THREE.MeshLambertMaterial({color: 0xffffff})]);

		tubeMesh.name = tubeMesh;
		tubes.push(tubeMesh);
		scene.add(tubeMesh);  
		
		console.log(scene);
		width = window.innerWidth;
		height = window.innerHeight;

		//define camera
		//camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
		camera = new THREE.OrthographicCamera( width /  2, width / -2, height / -2, height /  2, 1, 10000 );
		camParent = new THREE.Object3D();
		

		camera.position.set (0, 0, -1000);
		camera.lookAt (new THREE.Vector3(0, 0, 0)); 
		camParent.add(camera);
		scene.add(camParent);

		//define material (blue line in this case)
		material = new THREE.LineBasicMaterial({
			color: 0x0000ff
		});
	}

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	//document.addEventListener( 'mouseup', onDocumentMouseUp, false );
	//document.addEventListener('mousewheel',scrollFunc,false);


	function onDocumentMouseDown( event ) {
		if(event.clientY>20)
		draw = !draw;
	}

	function printVerts(){


		for(q in geometry.vertices){
			sverts += (geometry.vertices[q].x +"," + geometry.vertices[q].y+"," + geometry.vertices[q].z+",");
		}
		
	}
	
	function removal(){

		for (thing in tubes){
				scene.remove(tubes[thing]);

		}
	}
	function killGeo(){
		geometry.vertices = [];
		console.log(geometry);
	}

	function onDocumentMouseMove( event ) {

		if(draw && count == 0){
		
			var x=event.clientX;
			var y=event.clientY-20;
			z++;

			var zee = Math.sin(z);
			geometry.vertices.push(new THREE.Vector3(x-width/2, y-height/2, z));

			if(tubes.length>0){
				removal();
			}
			

			//draw a line from first to last vector, when more than 2 are present
			if (geometry.vertices.length > 2 && geometry.vertices.length < 200) {

				var line = new THREE.Line(geometry, material);

						
				var curve = new THREE.SplineCurve3(geometry.vertices);
				var geo = new THREE.TubeGeometry(curve, geometry.vertices.length*5, 12, 3, closed);
				tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geo, [new THREE.MeshLambertMaterial({color: 0xffffff})]);

				tubeMesh.name = tubeMesh;
				tubes.push(tubeMesh);
				scene.add(tubeMesh);  

			}
		}
	}

	function animate() {

		count++;
		//console.log(count);
		if(count%5==0)
			count=0;

		requestAnimationFrame( animate );
		renderer.render( scene, camera );

	}

	function sendDatabase(){
		$.post(" url? ", { sverts }, function(data,status,xhr){
			alert("Data: " + data +"\nStatus: " + status + "\nxhr: "+ xhr);
		});
	};


	</script>


{% endblock %}

{% block styles %}{% endblock %}
{% block scripts %}{% endblock %}